<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<meta name="robots" content="all" />
		
		<title>Superpose3D - Manual</title>
		
		
		<style type="text/css" media="all">p.code {margin-left: 5%; font-family:courier}</style>
		
	</head>
<body>
<div id="container"><!-- Start container -->
		<div id="contentContainer"><!-- Start main content wrapper -->
		<div id="content"><!-- Start content -->
			<h1><a name="index">Index</a></h1><br /><br /><ol class="arabic-numbers"><li><a href="#installation">Installation</a></li><li><a href="#files">Files included in the distribution</a></li><li><a href="#terminology">A bit of terminology</a></li><li><a href="#description">Description of the algorithm</a></li><li><a href="#complexity">Running time and complexity</a></li><li><a href="#command">Command line syntax and files needed by superpose</a></li><li><a href="#options">Specifying options and parameters</a></li><li><a href="#residues">Specifying protein residues</a></li><li><a href="#equivalences">Specifying equivalences</a></li><li><a href="#wildcards">Wildcards</a></li><li><a href="#modes">Modes</a></li><li><a href="#output">Output</a></li><li><a href="#visualizing">Superimposing PDB files and visualising the structural similarities</a></li></ol><br /><br /><a name="installation"><h2>Installation</h2></a><a href="#index"><h5>Back to top</h5></a><br />In order to compile superpose from sources you need CMake. CMake is a free and<br />open source cross-platform build system available at <a href="http://www.cmake.org/">http://www.cmake.org/</a>.<br />Cmake will be used to create a build environment specific for the OS you are<br />using. Detailed instructions for each system are given in the following<br />paragraphs.<br /><br /><ul class="disc"><li><a href="#macos">Mac OS</a></li><li><a href="#linux">Linux</a></li><li><a href="#windows">Windows</a></li></ul><br /><br /><h4><a name="macos">Mac OS</a></h4><br /><br />In order to compile superpose (or any C/C++ program for that matter!) you need<br />Xcode. This is an optional install available in the DVD you have received when<br />you bought your computer. Xcode is also available at <a href="http://developer.apple.com/technology/xcode.html">http://developer.apple.com/technology/xcode.html</a><br /><br /><br />Decompress the superpose archive, go into the Applications folder and start<br />CMake. In the CMake gui point the "Where the source code is" field to the<br />location of the superpose source code folder. Similarly point the "Where to<br />build the binaries" to the build/ subdir in the superpose folder. Next press<br />the configure button (bottom part of the window) and select as generator "Unix<br />Makefiles".  Press configure again until there are no more values in red in<br />the main portion of the window. Afterwards press the generate button. Open the<br />terminal go into the build/ subdirectory and type<br />	<br /><p class="code">make</p><br /><br />The build products will be located in build/src. If you want to inspect/modify<br />the sources you can create an Xcode project by choosing Xcode as the<br />generator. The project will be created in the build/ subdirecoty. Double click<br />on the file and everything should open in Xcode.<br /><br />Note: if you installed cmake via fink you can do all of the above from the<br />command line.  Decompress the superpose archive, go into the build/ subdir and<br />type<br /><br /><p class="code">cmake .. -G"Unix Makefiles&rdquo;<br/> 
	make</p><br /><br />The build products will be located in build/src. If you want to create an<br />Xcode project type<br />	<br /><p class="code">cmake .. -GXcode</p><br /><br />Important note: if you have troubles compiling the program, especially if you<br />get weird linking errors, you may have a version of Xcode that was not<br />installed in the version of the OS you are currently using. This happens for<br />instance when you migrate your programs (including Xcode) from an older Mac<br />with an earlier version of the OS. If this is the case please reinstall Xcode.<br /><br /><br /><a name="linux"><h4>Linux</h4></a><br /><br />You will need to have g++ installed. g++ will certainly be available in the<br />software repositories of your distribution so check there.<br />Decompress the superpose archive, go into the build/ subdir and type<br /><br /><p class="code">cmake ..<br/> 
	make</p><br /><br />The build products will be located in build/src. <br /><br /><a name="windows"><h4>Windows</h4></a><br /><br />CMake can create projects for a variety of development environments in Windows<br />(e.g. Borland, Microsoft Visual C++, Cygwin, Eclipse etc.). The instructions<br />that follow refer to Visual C++ but the steps are similar with any development<br />environment. Visual C++ Express is available for free at<br /><a href="http://www.microsoft.com/express/download/">http://www.microsoft.com/express/download/</a> Decompress the superpose archive.<br />Navigate the windows "start" menu to CMake(Cmake-gui) and start the CMake gui.<br />In the CMake gui point the "Where the source code is" field to the location of<br />the superpose source code folder. Similarly point the "Where to build the<br />binaries" to the build/ subdir in the superpose folder. Next press the<br />configure button (bottom part of the window) and select as generator the<br />version of Visual C++ that you are using.  Press configure again until<br />there are no more values in red in the main portion of the window. Afterwards<br />press the generate button.  This will create a Visual C++ project inside the<br />build/ subdir. Double-click on the project to open it with Visual C++. In the<br />Visual C++ window set the build type to Release using the drop-down menu<br />located in the middle of the tool bar and navigate to build -> Build<br />ALL_BUILD. This will start the compiler. The build products will be located in<br />the Release subdirectory of build/src. If you have troubles with all this<br />please refer to the Visual Studio documentation.  <strong>BIG FAT WARNING</strong>: If you are<br />on Windows specify all the paths that you give to superpose using / as the<br />directory separator!<br /><br /><a name="files"><h2>Files included in the distribution</h2></a><a href="#index"><h5>Back to top</h5></a><br /><br />The following files are all located in the data/ subdir. The parameters file<br />we provide will allow you to start comparing structures right away, without<br />the trouble of developing a structure representation yourself.<br /><br />pdb_res_dict.txt: a file containing all the aminoacids known to the program.<br />Please remember to set the pdb_res_dict option in the parameters files to<br />point to this file (see below, <a href="#options">&ldquo;Specifying options and parameters&rdquo;</a>)<br /><br />query3d_par.txt: a file of parameters corresponding to the representation used<br />in [Ausiello et al., BMC Bioinformatics. 2005 Dec 1;6 Suppl 4:S5].<br /><br />pints_par.txt: a file of parameters corresponding to the representation used<br />in [Stark et al., Nucleic Acids Res. 2003 Jul 1;31(13):3341-4].<br /><br />schmitt_par.txt: a file of parameters corresponding to the representation used<br />in [Schmitt et al., J Mol Biol. 2002 Oct 18;323(2):387-406]. <br /><br /><br /><a name="terminology"><h2>A bit of terminology</h2></a><a href="#index"><h5>Back to top</h5></a><br /><br />In the following documentation a "pseudoatom" is a point used by superpose to<br />represent a residue or part of it. A pseudoatom may correspond to an actual<br />protein atom, e.g. you could specifiy that a pseudoatom called CA is used to<br />represent the CA of a residue. However this is not always true. For instance<br />you could define a pseudoatom called "bar" which corresponds to the geometric<br />centroid of the side chain atoms. The term "pseudoatom" therefore designates<br />the points making up a residue in the internal representation used by the<br />program.  A "match" is a correspondence between the pseudoatoms describing two<br />protein structures. The match may involve complete residues, single<br />pseudoatoms, or a combination of the two (see below, <a href="#modes">&ldquo;Modes&rdquo;</a>). Obviously,<br />since this is a pairing, a match will always involve the same number of<br />elements in the two structures at hand.<br /><br /><a name="description"><h2>Description of the algorithm</h2></a><a href="#index"><h5>Back to top</h5></a><br /><br />The structural comparison algorithm uses a branch & bound strategy to find the<br />largest subset of residues (or part of them) between two protein structures<br />that can be superimposed under a given RMSD threshold, irrespective of their<br />position along the sequence. The user is completely free to specify the way in<br />which protein structures will be represented during the comparison.  Users can<br />also specify equivalence criteria between residues. Only residues which have<br />been defined as equivalent will be paired.<br /><br /><br />The algorithm starts by creating all the possible pairs of equivalent<br />pseudoatoms in the two structures (i.e. matches of length 1). These matches<br />are extended by generating all the possible length 2 matches starting from<br />each length 1 match. For this purpose all the possible pairs of residues (or<br />pseduoatoms depending on the mode) which are close to those already belonging<br />to the match (i.e. having a pair of pseudoatoms at distance lower than a given<br />threhsold) are addedd to the first two. For instance, let the first aminoacid<br />in the probe structure have i neighbours and the corresponding matched<br />aminoacid in the target structure have j neighbours. The algorithm generates i<br />x j new matches of length 2. All the matches are evaluated and kept if their<br />constituent residues can be superimposed with a RMSD lower than the threshold<br />currently in use. The optimal superimposition between two sets of points is<br />calculated using the Quaternion method [Coutsias et al., J Comput Chem 2004,<br />25:1849-1857]. The matches that have been retained are then recursively<br />extended to length 3 and so on.<br /><br /><a name="complexity"><h2>Running time and complexity</h2></a><a href="#index"><h5>Back to top</h5></a><br /><br />The complexity of the procedure is clearly exponential in the size of the<br />probe and target chains.However using appropriate RMSD and given the average<br />size of protein chains, meaningful results can generally be obtained rather<br />quickly. The bottom line is that the algorithm runs faster as a greater<br />number of matches fail in the early stages of the exploration. This allows an<br />early pruning of the search tree which results in fewer matches having to be<br />considered for extension. If superpose is taking too long to complete you can speed it up<br />by lowering the RMSD threshold, and evenutally choosing stricter pairing<br />rules, so that fewer combinations of residues are considered. Also critical is the<br />structural similarity of the proteins given as input. The more similar they<br />are, the more seed matches that will have to be considered for extension. Please<br />remember that this software is about <strong>local</strong> structural similarities. If you<br />have two proteins which are globally similar you will be better off using a<br />fold comparison method such as DALI [Holm and Sander, J Mol Biol 1993,<br />233:123-138].<br /><br /><a name="command"><h2>Command line syntax and files needed by superpose</h2></a><a href="#index"><h5>Back to top</h5></a><br /><br />You can launch the program using the following syntax<br /><br /><p class="code">superpose -i [input file] -p [parameters file] [-o [out file]] [-v]</p><br /><br />The command line arguments can be specified in any order, -o is optional as<br />the name of the output file can also be provided as an option in the input<br />file (see below). The -v option turns on verbose output. In addition you will<br />also need the pdb_res_dict.txt file located in the data/ directory of the<br />superpose distribution. This is a file containing a list of all the residues<br />known to the program, along with their constituent atoms. If an aminoacid is<br />not in there it will not be considered when parsing the PDB file. The name of<br />these residues and their constituent atoms were taken from the Chemical<br />Component Dictionary (CCD) available from the PDB website<br />(<a href="http://www.wwpdb.org/ccd.html">http://www.wwpdb.org/ccd.html</a>). The syntax of the file used by superpose,<br />which you are free to modify to add your custom residues if necessary, is as<br />follows:<br /><br /><p class="code">[3 letter code] [3 letter code of the parent amino acid] [one letter code of the parent aa] [","-separated list of heavy atoms]</p><br /><br />The parent aminoacid is the standard aminoacid from which a modified aa<br />derives (e.g. for phospho-threonine, TPO, the parent aa is threonine, THR).<br />This corresponds to the _chem_comp.mon_nstd_parent_comp_id field in the CCD<br />file.<br /><br /><br /><a name="options"><h2>Specifying options and parameters</h2></a><a href="#index"><h5>Back to top</h5></a><br /><br />Options and parameters used by superpose are always specified with the syntax<br /><br /><p class="code">[key] [value]</p><br /><br />where key and value are separated by a single space. Each key/value pair has<br />to go on a different line except for the "def" and "equiv" keys that can span<br />multiple lines (see below). A description of the options and parameters<br />recognized by the program follows. The letter in parenthesis after the key<br />name specifies whether the option should be placed in the parameters (<strong>P</strong>) or<br />input (<strong>I</strong>) file. This letter is only used here and is not part of the key name.<br /><br /><br />	def (<strong>P</strong>): this is the keyword used to prefix lines containing the<br />	definition of protein residues (see "Specifying protein residues")<br />	<br />	equiv (<strong>P</strong>): this is the keyword used to prefix lines containing the<br />	definition of equivalences (see "Specifying equivalences")<br /><br />	rmsd_threshold (<strong>P</strong>): the maxium RMSD of a match, default 0.7<br /><br />	pdb_res_dict (<strong>P</strong>): the full path to the file containing the dictionary of<br />	PDB residues known to the program, see "Files needed by superpose"<br /><br />	neighbour_threshold (<strong>P</strong>): the distance threshold under which two residues<br />	(or pseudoatoms depending on the mode, see <a href="#modes">&ldquo;Modes&rdquo;</a>) are considered<br />	neighbours, see <a href="#description">&rdquo;Description of the algorithm&rdquo;</a> for additional details.<br /><br />	score_min (<strong>P</strong>): the minimum length of a match, default 3<br /><br />	score_max (<strong>P</strong>): the maximum length of a match, default 10<br /><br />	max_longest_matches (<strong>P</strong>): the maximum number of matches of maximum score<br />	that will be reported, after this limit is reached the program will<br />	stop looking for additional matches between the same pair of proteins.<br />	Please note: if you hit this limit the output you are looking at is<br />	very likely _not_ what you want. The matches reported by the program<br />	will be the _first_ found during the exploration. There might very<br />	well be better matches of the same length that are not reported<br />	because this limit was reached and therefore the exploration stopped. This<br />	threshold is essentially a safeguard against the possibility that<br />	superpose will waste a huge amount of time in the comparison of two<br />	closely related structures (see <a href="#description">"Description of the algorithm&rdquo;</a> for<br />	clarifications). Default is 5; -1 means unlimited (Use at your own risk!).<br /><br />	mode (<strong>P</strong>): the mode used by superpose (see, <a href="#modes">&ldquo;Modes&rdquo;</a>). Default res; possible<br />	values: res, res_multiple, atom<br /><br />	probe (<strong>I</strong>): the protein chain(s) to be used as probe(s). These are specified<br />	as follows, separated by ";":<br /><br /><p class="code">[pdb file]([chain][:residue range])</p><br /><br />	residue ranges are specified either as a ","-separated list of residue<br />	numbers (as specified in the resSeq PDB field) or as a "-"-separated<br />	lower and upper range limits, or as a combination of both. The chain<br />	is mandatory. You can type * as the chain and the program will load<br />	all the chains contained in the file. Instead of a single file you can<br />	also specify the name of a directory by enclosing it in square<br />	brackets. In this case the program will traverse the directory<br />	recursively, trying to load all the files it finds. In this case, if<br />	you specify a chain or a residue range the expression will be applied<br />	to each file. Examples of valid probe definitions:<br /><br /><p class="code">probe pdb101m.ent(A:12,34,80-90,40-50);pdb102m.ent(A)<br/>
		probe [subdir/](*) #This means all the chains in all the files contained in the subdirectory "subdir"</p><br />	<br />	It is also possible to specify as input a zone comprising all the<br />	residues within a given distance from a central residue. The syntax is<br />	as follows:<br /><br /><p class="code">[pdb file]([chain][:central residue]z[distance threshold])</p><br /><br />	For instance<br /><br /><p class="code">probe pdb101m.ent(A:120z6.5)</p><br /><br />	The above statement selects all the residues whose distance from<br />	residue 120 of chain A is less than 6.5 Angstroms. To inspect which<br />	residues the program is selecting you can use the -v command line<br />	option for turning verbose output on.<br />	<br />	target (<strong>I</strong>): the protein chain(s) to be used as target(s). The syntax<br />	is the same as for probes. If only probes are provided the program<br />	will compare each one of them against all the others. Otherwise each<br />	probe will be compared with each target.<br /><br />	pdb_dir (<strong>I</strong>): the directory containing the pdb_files, defaults to the<br />	current directory. If a directory is given this will be prepended to<br />	all the file and directory names specified in "probe" and "target"<br /><br />	output_file(<strong>I</strong>): full path to the output file. Defaults to the basename<br />	of the input wit "_out.txt" appended. <strong>Warning</strong>: if the file already<br />	exists it will be overwritten!<br /><br /><br /><br /><a name="residues"><h2>Specifying protein residues</h2></a><a href="#index"><h5>Back to top</h5></a><br /><br />Each residue is specified in a line starting with the keyword "def". The<br />format is as follows:<br />	<br /><p class="code">def [PDB residue name]=[atom1]:[pseudoatom name];[atom2]:[pseudatom name]</p><br /><br />PDB residue name should be the three-letter code of the residue as found in<br />the PDB file (e.g. ALA for alanine). The "=" sign is followed by a<br />";"-delimited list of atoms that define the residue at hand. The atom naming<br />scheme is the one defined in the PDB Chemical Compound Dictionary. In the case<br />of glycine residues the program will add a "fake" CB atom while parsing the PDB<br />file. The coordinates of this atom are calculated from the N, CA and C atoms<br />so as to have a tetrahedral geometry at the CA.  You can also specify a name<br />of your choice for each atom after the ":" (e.g. CA:bar, associates the name<br />bar to the CA atom). The rationale for assigning custom names will be clear<br />when we discuss residue equivalences (see <a href="#equivalences">below</a>). If you do not specify any custom name<br />the atom name will be used to label the point.<br /><br /><br />It is also possible to define a "pseudoatom" as the geometric centroid of a<br />user-specified list of PDB atoms.<br />The syntax is as follows:<br /><br /><p class="code">avg(CA,C,O):bar</p><br /><br />This clause defines a pseudoatom named "bar" whose coordinates are calculated<br />as the geometric centroid of the CA, C and O atoms. Note that in this case it<br />is mandatory to assign a name to the pseudoatom (i.e. the above clause would<br />be invalid without the ":bar" part).  Inside the "avg" clause you can also use<br />the keyword "side_chain" which designates all the atoms except the main chain<br />ones (e.g. N, CA, C, O).<br /><br />The definitions that follows should clarify the syntax.<br /><br /><p class="code">def ALA=CA;N;C<br/>
	def ALA=CA;N:bar;C</p>
<br />The above definitions all specify alanine as represented by three atoms (CA,<br />N, C). The second one also assigns the label "bar" to the N atom.<br /><br /><p class="code">def TRP=CA;avg(side_chain):foo</p><br /><br />This defines TRP as represented by the CA plus a pseudoatom called "foo" and<br />calculated as the geometric centroid of the side chain.<br /><br /><p class="code">def GLU=avg(OE1,OE2,CG):acidic</p><br /><br />This specifies GLU as the geometric centroid of the OE1, OE2, and CG atoms.<br />This pseudoatom is assigned the label "acidic"<br />Note that the same atom can appear in different avg clauses, e.g. the<br />following definition is perfectly valid<br /><br /><p class="code">def GLU=agv(OE1,CG):acidic1;avg(OE2,CG):acidic2</p><br /><br />The only requirement is that the user-specified names must be unique in the<br />definition of each residue (e.g.: using "acidic" for both pseudoatoms would<br />have been invalid). However they may repeat between residues (e.g. two different<br />residues may each have a pseudoatom called "acidic").<br /><br /><br /><a name="equivalences"><h2>Specifying equivalences</h2></a><a href="#index"><h5>Back to top</h5></a><br /><br />Once you have defined the points that the program should use to represent<br />residues you have to provide a list of equivalences. These statements specify<br />which residues are allowed to match and which points should be used for the<br />superimposition. These deifinitions are given in lines starting with the<br />"equiv" keyword.<br />The syntax is as follows<br /><br /><p class="code">equiv [res]{.[atom]}=[res]{.[atom]}=[res]{.[atom]}</p><br /><br />The .[atom] part is optional so let's start with the basic case.<br /><br /><p class="code">equiv ALA=GLY=VAL</p><br /><br />Tells the program that the residues ALA, GLY and VAL are equivalent and can be<br />matched with each other. Note that if you want identical residues to match you<br />have to explicitly specify it! e.g. if the above line is the only equivalence<br />you provide the program will _not_ pair ALA with ALA, GLY with GLY and VAL with<br />VAL. If you want this three residues to pair with each other and also with<br />themselves you have to used the following lines<br /><br /><p class="code">equiv ALA=ALA<br/>
	equiv GLY=GLY<br/>
	equiv VAL=VAL<br/>
	equiv ALA=GLY=VAL</p><br /><br />Even though this may seem redundant it allows you to exclude certain residue<br />pairs altogether. For instance if you do not want to see matches between<br />hydrophobic residues you can leave them out from the list of equivalences and<br />you will not even see matches of residues of the same type.<br /><br />An alternative way to specify equivalences is the following<br /><br /><p class="code">equiv ALA=GLY;VAL</p><br /><br />Note that the residues on the right side of the &lsquo;=&lsquo; sign are separeted by a &lsquo;;&rsquo;. This means<br />that ALA can be matched with GLY and VAL but does not imply that GLY and VAL can<br />be matched together. Using this syntax you can specify, for each residue, the allowed substitutions<br />instead of simply defining groups of residues which are all equivalent.<br /><br />When you specify, as in the above examples, an equivalence that involves the<br />whole residue (i.e. you have omitted the .[atom] part), the points that make<br />up each residue will be paired in the same order as they appear in the<br />definition. e.g.<br /><br /><p class="code">def ALA=CA;O<br/>
	def VAL=CA;O<br/><br/>

	equiv ALA=VAL</p><br /><br />means that, in superimposing ALA and VAL, the program will pair CA with CA and<br />O with O. If you define the residue as follows<br /><br /><p class="code">def ALA=CA;O<br/>
	def VAL=O;CA<br/><br/>

	equiv ALA=VAL</p><br /><br />The CA and O of ALA will be paired with the O and CA of VAL, respectively.<br /><br />If you want you can specify equivalences between specific residue fragments as<br />defined in the residue definition section. For instance if your residue definition<br />looks like this<br /><br /><p class="code">def=ALA=CA;avg(side_chain):bar<br/>
	def ASP=CA;CB;OG1</p><br /><br />you could write the following equivalence<br /><br /><p class="code">equiv ALA.bar=ASP.OG1</p><br /><br />You can also specify multiple atoms together, e.g.:<br /><br /><p class="code">equiv ALA.CA-bar=ASP.CA-OG1</p><br /><br />Once again atoms will be paired according to the order in which they are written<br />(i.e. in the above case CA with CA and bar with OG1).<br />The atom names that you can use in these statements are the ones that you have<br />defined when specifying protein residues (see above).<br /><br /><a name="wildcards"><h2>Wildcards</h2></a><a href="#index"><h5>Back to top</h5></a><br /><br />In specifying residue definitions and equivalences you can use wildcards. Two<br />types of wildcards are available "*" and "\". "*" is used in residue names and<br />it means "Any residue that does not match a more specific definition". "\" is<br />used in atom names with the meaning "Any atom whose name contains this<br />string". We will now describe in more detail how this wildcards apply to residue<br />definitions and equivalences. Please note that the only wildcard that can be<br />used in "res" mode is "*" when specifying residue definitions. Conversely all<br />the wildcards can be used in "res_multiple" and "atom" modes (see <a href="#modes">below</a>).<br /><br />The "*" in residue definitions is used to provide a definition for all the<br />remaining residues for which a more specific definition is not present. For<br />instance <br /><br /><p class="code">def ALA=CA;CB<br/>
	def ASP=CA;avg(side_chain):bar<br/>
	def *=CA</p><br /><br />means that ALA and ASP will be represented as specified, while all the other<br />residues will be defined by the CA only. Note that it is always a good idea to<br />include a catch all definition (i.e. using "*") at the end of the more<br />specific statements because the program will exit when a residue, for which no<br />definition is available, is encountered while parsing the PDB file.<br /><br />The "\" in atom names is expanded, by looking at the PDB residue dictionary<br />(see <a href="#command">&rdquo;Command line syntax and files needed by superpose&rdquo;</a>), to all the atoms<br />whose name matches the string following the "\". For instance<br /><br /><p class="code">def ASP=\O</p><br /><br />is equivalent to<br />	<br /><p class="code">def ASP=O;OD1;OD2</p><br /><br />given that the line in the PDB residue dictionary for ASP is<br /><br /><p class="code">ASP     ASP     D       N,CA,C,O,CB,CG,OD1,OD2</p><br /><br />The "\" inside an "avg" clause are treated in the same way.<br /><br />Similarly, in specifying equivalences, the "*" means "Any residue for which a<br />specific equivalence has not been provided" and "\" "All the atoms whose name<br />matches the string following the "\". <br /><br />These wildcards are especially useful if one wants to do atom-based<br />comparisons. For instance the following parameters file<br /><br /><p class="code">mode atom<br/><br/>

	def *=\N;\O<br/><br/>

	equiv *.\N=*.\N<br/>
	equiv *.\O=*.\O</p><br /><br />means that all the residues should be represented with their nitrogen and<br />oxygen atoms and that only atoms of the same type are allowed to match.<br /><br /><a name="modes"><h2>Modes</h2></a><a href="#index"><h5>Back to top</h5></a><br /><br />superpose can operate in three different modes which are explained below:<br /><br />- res: In this mode the program will always output matches between pairs of<br />  residues. You'll never see cases where the same residue matches two<br />  different residues with different pseudoatoms. Moreover In the equivalences <br />  section you can only specify one way to superimpose the same pair of residues.<br />  In other words something like this:<br /><br />  <p class="code">equiv ALA.CA=ASP.CA<br/>
	equiv ALA.CB=ASP.CB</p><br />	<br />  would be invalid because you have specified two alternative ways to<br />  superimpose the same pair of residues, ALA and ASP.<br /><br />- res_multiple: this is similar to res mode. The difference is that in this<br />  mode you can specify multiple ways to superimpose the same pair of residues.<br />  During the computation the algorithm will select, for each pair of<br />  residues of the structure, what is the optimal way to superimpose them.<br /><br />- atom: this is similar to res_multiple. The difference is that in this mode<br />  all the pseudoatoms that define a residue are treated independently.<br />  Therefore the program may output matches where the same residue is paired<br />  with two or more different residues using different pseudoatoms. For<br />  instance you might have the CA of res 1 matching with the CA of res 2 in the<br />  other structure and the CB of res 1 matching with the CB of res 3. In other<br />  words in this mode the notion of residue is abolished and every pseudoatom<br />  you have defined is treated as a different entity.<br /><br />Aside from these differences the additional thing to consider is that mode<br />"res" is slightly faster than the other two. Modes are specified in the<br />parameter file (See <a href="options">&ldquo;Specifying options and parameters&rdquo;</a>).<br /><br /><a name="output"><h2>Output</h2></a><a href="#index"><h5>Back to top</h5></a><br /><br />The output is structured as follows:<br /><br /><p class="code">[match_id] [probe] [taget] [probe size] [target size] [rmsd] [length] [residue pairs] [trans]</p><br /><br />The match_id is just a numeric id for the match, each match is located on a<br />different line. Probe and target are the chains involved in the match. Probe<br />and target sizes are the number of elements that can be independently matched<br />comprising the probe and the target chains. This is equal to the number of<br />residues for the "res" and "res_multiple" modes and the total number of<br />pseudoatoms in "atom" mode. This is useful if you want to calculate statistics<br />based e.g. on the ratio between the size of the match and the size of the<br />chains used as input.<br />The residue pairs give the correspondences between the two structures.  If you<br />are in "res_multiple" or "atom" and you have specified equivalences between<br />fragments of residues the name of the aminoacid will be followed by the name<br />of the fragment that has matched.  Trans is a set of 15 numbers which<br />represent the geometric transformation to be applied to the original pdb files<br />in order to superimpose the structures according to the match. The first 3<br />numbers are the translation along the x, y and z axis to be applied to the<br />probe. Similarly the following 3 represent the translation for the target. The<br />last 9 numbers are the three rows of the 3x3 rotation matrix which has to be<br />applied, after the translation, to the target <strong>only</strong>.<br /><br /><a name="visualizing"><h2>Superimposing PDB files and visualizing the structural similarities</h2></a><a href="#index"><h5>Back to top</h5></a><br /><br />Superpose will compare the two protein structures but it will not create<br />coordinate files with the structures roto-translated according to the<br />structural match. In order to transform the PDB files you need the program<br />superpose_pdb_files which is built together with superpose and should be<br />located in the build/src subdir (see, <a href="#installation">&rdquo;Installation&rdquo;</a>). The syntax of this<br />program is as follows:<br /><br /><p class="code">superpose_pdb_files [-i input_file] [-d list of pdb file dir]</p><br /><br />input_file is the output file from superpose, containing the matches that you<br />want to visualize, "list of pdb file dir" is a list of directories containing<br />the original pdb files which have been used as input to superpose. The program<br />will look in each directory trying to find the files and abort with an error<br />if it fails.  For each line in the input file (i.e. each match) this program<br />will create three files:<br /><br /><p class="code">[probe]_rot[match_id].ent<br/>
	[target]_rot[match_id].ent<br/>
	chim_[match_id].cmd</p>
<br />The first two files are the PDB files of the probe and target rotated and<br />translated according to the structural match having the given match_id. You<br />can visualize them using any molecular graphics program of your choice.<br />The third file is a script to be used with the excellent molecular viewer<br />Chimera (available for free at <a href="http://www.cgl.ucsf.edu/chimera/">http://www.cgl.ucsf.edu/chimera/</a>). To run the<br />script in chimera place all the three files in the same directory, open<br />chimera and fire up the command line (menu favorites -> command line)<br />In the command line type<br /><br /><p class="code">cd [name of dir where you put the files]<br/>
	source [name of the file containing the chimera script]</p><br /><br />You should see the two structures with the residues comprising the match<br />represented as sticks and the remainder of the proteins depicted in ribbon<br />representation.<br /><br /><br /><br /><br /><br /><br /><br />
		</div><!-- End content -->
		<div class="clearer"></div>
	</div><!-- End main content wrapper -->
</div><!-- End container -->
</body>
</html>
